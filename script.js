let gameData = {
      "decks": [
        {
          "code": "w-humans",
          "name": "Humans",
          "set": "basic",
          "color": "w",
          "description" : "Ifn it white, it aint right."
        },
        {
          "code": "w-lifegain",
          "name": "Lifegain",
          "set": "intermediate",
          "color": "w",
          "description" : "Gain some life yo."
        },
        {
          "code": "w-vehicles",
          "name": "Vehicles",
          "set": "intermediate",
          "color": "w",
          "description" : "Boats and hoes."
        },
        {
          "code": "w-auras",
          "name": "Auras",
          "set": "advanced",
          "color": "w",
          "description" : "Pump yo dudes."
        },
    
    
        {
          "code": "u-gowide",
          "name": "Blue Go Wide",
          "set": "basic",
          "color": "u",
          "description" : "Zombie swarm fo yo ass."
        },
        {
          "code": "u-draw",
          "name": "Draw",
          "set": "intermediate",
          "color": "u",
          "description" : "Draw dem cards."
        },
        {
          "code": "u-spirits",
          "name": "Spirits",
          "set": "intermediate",
          "color": "u",
          "description" : "Spook magook boys."
        },
        {
          "code": "u-tempo",
          "name": "Tempo",
          "set": "advanced",
          "color": "u",
          "description" : "freeze biatch."
        },
    
        
        {
          "code": "b-aggro",
          "name": "Black Aggro",
          "set": "basic",
          "color": "b",
          "description" : "Beatdown boys."
        },
        {
          "code": "b-control",
          "name": "Black Control",
          "set": "intermediate",
          "color": "b",
          "description" : "Yo shit ded."
        },
        {
          "code": "b-sacrifice",
          "name": "Sacrifice",
          "set": "intermediate",
          "color": "b",
          "description" : "Sac and smack."
        },
        {
          "code": "b-discard",
          "name": "Discard",
          "set": "advanced",
          "color": "b",
          "description" : "Hide yo cards."
        },
    
    
        {
          "code": "r-rdw",
          "name": "RDW",
          "set": "basic",
          "color": "r",
          "description" : "Smash face."
        },
        {
          "code": "r-bigred",
          "name": "Big Red",
          "set": "intermediate",
          "color": "r",
          "description" : "Big red boys that like to hurt people."
        },
        {
          "code": "r-artifacts",
          "name": "Artifacts",
          "set": "intermediate",
          "color": "r",
          "description" : "Create and destroy robots."
        },
        {
          "code": "r-burn",
          "name": "Burn",
          "set": "advanced",
          "color": "r",
          "description" : "Come on Pookie, lets burn this mf down."
        },
    
    
        {
          "code": "g-devotion",
          "name": "Green Devotion",
          "set": "basic",
          "color": "g",
          "description" : "Green is good.",
          "decklist" : [
            {
              "cardName": "Silver Back Shaman",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 5,
              "copies" : 1
            },
            {
              "cardName": "Garenbrig Paladin",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 5,
              "copies" : 1
            },
            {
              "cardName": "Renata, Called to the Hunt",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 4,
              "copies" : 1
            },
            {
              "cardName": "Nylea's Huntmaster",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 4,
              "copies" : 1
            },
            {
              "cardName": "Voracious Typhoon",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 4,
              "copies" : 1
            },
            {
              "cardName": "Strangleroot Geist",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 2,
              "copies" : 1
            },
            {
              "cardName": "Barkhide Troll",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 2,
              "copies" : 1
            },
            {
              "cardName": "Kalonian Tusker",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 2,
              "copies" : 1
            },
            {
              "cardName": "Young Wolf",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 1,
              "copies" : 1
            },
            {
              "cardName": "Elvish Mystic",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 1,
              "copies" : 1
            },
            {
              "cardName": "Bushwack",
              "cardType": "Sorcery",
              "color": "g",
              "manaValue" : 1,
              "copies" : 1
            },
            {
              "cardName": "Aspect of Hydra",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 4,
              "copies" : 1
            },
            {
              "cardName": "Rhona's Monument",
              "cardType": "Creature",
              "color": "g",
              "manaValue" : 4,
              "copies" : 1
            },
            {
              "cardName": "Thriving Grove",
              "cardType": "Land",
              "color": "c",
              "manaValue" : 0,
              "copies" : 1
            },
            {
              "cardName": "Hashep Oasis",
              "cardType": "Land",
              "color": "c",
              "manaValue" : 0,
              "copies" : 1
            },
            {
              "cardName": "Forest",
              "cardType": "Land",
              "color": "c",
              "manaValue" : 0,
              "copies" : 5
            }
          ]
        },
        {
          "code": "g-deathtouch",
          "name": "Deathtouch",
          "set": "intermediate",
          "color": "g",
          "description" : "Wait. What dart?"
        },
        {
          "code": "g-ramp",
          "name": "Ramp",
          "set": "intermediate",
          "color": "g",
          "description" : "Get out the lands."
        },
        {
          "code": "g-counters",
          "name": "Counters",
          "set": "advanced",
          "color": "g",
          "description" : "Buff boys ready to pump you up."
        },
    
    
        {
          "code": "wu-fliers",
          "name": "Uw Fliers",
          "set": "intermediate",
          "color": "wu",
          "description" : "Just some feathered friends."
        },
        {
          "code": "wu-drawgo",
          "name": "Wu Draw Go",
          "set": "advanced",
          "color": "wu",
          "description" : "Pass the turn."
        },
    
    
        {
          "code": "wb-clerics",
          "name": "Wb Clerics",
          "set": "intermediate",
          "color": "wb",
          "description" : "Hail satan!"
        },
        {
          "code": "wb-drain",
          "name": "Bw Drain",
          "set": "advanced",
          "color": "wb",
          "description" : "Slurrrp."
        },
    
    
        {
          "code": "wr-equipment",
          "name": "Rw Equipment",
          "set": "intermediate",
          "color": "wr",
          "description" : "Suit up."
        },
        {
          "code": "wr-gowide",
          "name": "Wr Go Wide",
          "set": "advanced",
          "color": "wr",
          "description" : "Hope you like tokens."
        },
    
    
        {
          "code": "wg-coven",
          "name": "Gw Coven",
          "set": "intermediate",
          "color": "wg",
          "description" : "Three its the magic number."
        },
        {
          "code": "wg-enchantress",
          "name": "Wg Enchantress",
          "set": "advanced",
          "color": "wg",
          "description" : "Enchantments for your enchantments."
        },
    
    
        {
          "code": "ub-zombies",
          "name": "Bu Zombies",
          "set": "intermediate",
          "color": "ub",
          "description" : "Brains are back on the menu."
        },
        {
          "code": "ub-looting",
          "name": "Ub Looting",
          "set": "advanced",
          "color": "ub",
          "description" : "Toss it in the bin."
        },
    
    
        {
          "code": "ur-izzet",
          "name": "Ru Izzet",
          "set": "intermediate",
          "color": "ur",
          "description" : "Mad scientist magic."
        },
        {
          "code": "ur-artificers",
          "name": "Ur Artificers",
          "set": "advanced",
          "color": "ur",
          "description" : "Animating some shit."
        },
    
    
        {
          "code": "ug-spellramp",
          "name": "Gu Spell Ramp",
          "set": "intermediate",
          "color": "ug",
          "description" : "Magic its what plants crave."
        },
        {
          "code": "ug-selfmill",
          "name": "Ug Self Mill",
          "set": "advanced",
          "color": "ug",
          "description" : "The library is a resource."
        },
    
    
        {
          "code": "br-vampires",
          "name": "Rb Vampires",
          "set": "intermediate",
          "color": "br",
          "description" : "Ah ah ah ah."
        },
        {
          "code": "br-sacrifice",
          "name": "Br Sacrifice",
          "set": "advanced",
          "color": "br",
          "description" : "Plenty of meat for the grinder."
        },
    
    
        {
          "code": "bg-elves",
          "name": "Gb Elves",
          "set": "intermediate",
          "color": "bg",
          "description" : "Lean mean and green."
        },
        {
          "code": "bg-reanimator",
          "name": "Bg Reanimator",
          "set": "advanced",
          "color": "bg",
          "description" : "Look who's back."
        },
    
    
        {
          "code": "rg-gruul",
          "name": "Gr Gruul",
          "set": "intermediate",
          "color": "rg",
          "description" : "Oh look some stuff to smash."
        },
        {
          "code": "rg-domain",
          "name": "Gr Domain",
          "set": "advanced",
          "color": "rg",
          "description" : "Pick a color any color."
        }
      ]
    }
    
  

// ============================================================================
// Initialize the draft parameters and generate interface elements
var draftNumPlayers = new URLSearchParams(window.location.search).get("draftNumPlayers");
    draftNumPlayers = parseInt(draftNumPlayers);
var arrPlayerData = [];

var draftFirstPlayerType = new URLSearchParams(window.location.search).get("draftFirstPlayerType");
var draftSet = new URLSearchParams(window.location.search).get("draftSet");
var draftPickType = new URLSearchParams(window.location.search).get("draftPickType"); // "p1" or "randomized"
var draftBans = new URLSearchParams(window.location.search).get("draftBans");

var draftDeckData = structuredClone(gameData.decks);


// create arrPlayerData and populate with players, also generate playerCard blocks
for (let i = 0; i < (draftNumPlayers); i++) {

  var playerNum = (i + 1);
  var playerName = new URLSearchParams(window.location.search).get("p" + playerNum + "Name");

  /* create player data object and add to array
  const player = {
    name: playerName,
    data: "Here is some pointless data!"
  };
  arrPlayerData.push(player);*/

  var playerCardContainer = document.getElementById("js-playerCard-container");
  var playerCard = document.createElement('div');

  playerCard.classList.add('playerCard');
  playerCard.classList.add('playerCard--p' + playerNum);
  
  playerCard.innerHTML = `
      <div class="playerCard__deckPick" id="js-playerCard-p` + playerNum + `-pick1"></div>
      <input type="hidden" name="p` + playerNum + `Pick1" id="js-p` + playerNum + `-pick1-input" value="none">
      <div class="playerCard__deckPick" id="js-playerCard-p` + playerNum + `-pick2"></div>
      <input type="hidden" name="p` + playerNum + `Pick2" id="js-p` + playerNum + `-pick2-input" value="none">
      <h2 class="playerCard__playerName" id="js-playerCard-p` + playerNum + `Name">` + playerName + `</h2>
      <p class="playerCard__subHeading" id="js-playerCard-p` + playerNum + `Subheading"></p>`

    playerCardContainer.appendChild(playerCard);

}

//console.log(arrPlayerData);

// create game state hidden inputs
var draftStateDataElement = document.getElementById("js-draft-state-data");
var stateDataInput = document.createElement("input");
stateDataInput.type = "hidden";
stateDataInput.value = "none";
stateDataInput.name = "draftCurrentDeckSelection";
stateDataInput.id = "js-draftCurrentDeckSelection";
draftStateDataElement.appendChild(stateDataInput);

stateDataInput = document.createElement("input");
stateDataInput.type = "hidden";
stateDataInput.value = "none";
stateDataInput.name = "draftCurrentPickTarget";
stateDataInput.id = "js-draftCurrentPickTarget";
draftStateDataElement.appendChild(stateDataInput);

let deckGrid = document.getElementById('js-deckGrid');
let deckInfoLeft = document.getElementById('js-deckLightbox__contentLeft');
let deckInfoRight = document.getElementById('js-deckLightbox__contentRight');
let draftConfirmPickButton = document.getElementById('js-confirm-pick-button');

let draftCurrentPickTarget = document.getElementById('js-draftCurrentPickTarget'); // current pick target hidden element
let draftCurrentDeckSelection = document.getElementById('js-draftCurrentDeckSelection'); // current selected deck hidden element
let draftCurrentPlayerDeckPick = ""; // player card deck image for current pick

//console.log(draftCurrentDeckSelection);


// on change of current pick target hidden input, prepare for a draft pick (or clear styling if no pick)
draftCurrentPickTarget.addEventListener('change', function(event) {

  console.log('draftCurrentPickTarget.addEventListener CHANGE triggered -- value: ' + this.value)

  if (this.value == "none") {

    // no current draft pick, clear styling
    console.log('no current pick');

    deckGrid.classList.remove("deckGrid--p1Pick");
    deckGrid.classList.remove("deckGrid--p2Pick");
    deckGrid.classList.remove("deckGrid--p3Pick");
    deckGrid.classList.remove("deckGrid--p4Pick");

    const playerCardElements = document.querySelectorAll('.playerCard__deckPick');
    playerCardElements.forEach(element => {

      // remove class to disable highlight of current player's playerCard block
      var pickTargetplayerCardElement = element.parentElement;
      pickTargetplayerCardElement.classList.remove('playerCard--pickTarget');

      // remove class to disable highlight current deckPick element
      element.classList.remove('playerCard__deckPick--pickTarget');

    });

    // have all players picked for this round?
    console.log("have all players picked for this round? " + eval((draftNumPlayers-1) == intDraftPicksCurrentPlayerIndex));

    if ((draftNumPlayers-1) == intDraftPicksCurrentPlayerIndex) { // TODO rewrite this whole section
      
      // all players have picked a deck for this round
      console.log('all players have picked for this round.');

      // move to next pick in the array arrDraftPicksOrdering
      console.log(arrDraftPicksOrderingCurrent);
      arrDraftPicksOrderingCurrent = arrDraftPicksOrderingCurrent + 1;
      
      // go to the first player in the arrDraftPicksPlayerOrder array
      intDraftPicksCurrentPlayerIndex = 0;

      // figure out what type of pick this is (deck or ban)
      console.log("arrDraftPicksOrdering[current]: " + arrDraftPicksOrdering[arrDraftPicksOrderingCurrent]);
      if (arrDraftPicksOrdering[arrDraftPicksOrderingCurrent] == "deck") {

        // set value of next pick based on player order
        draftCurrentPickTarget.value = 'p'+ arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex] + '-pick' + getPlayerPickNumber(arrDraftPicksPlayerOrder[arrDraftPicksOrderingCurrent]);
        draftCurrentPickTarget.dispatchEvent(new Event('change'));

      } else if (arrDraftPicksOrdering[arrDraftPicksOrderingCurrent] = "ban") {

      // set value of next pick based on player order
      draftCurrentPickTarget.value = 'p'+ arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex] + '-ban';
      draftCurrentPickTarget.dispatchEvent(new Event('change'));


      } else {alert('yo somethin is up!');}


    } else {

      // not all players have picked a deck for this round
      console.log('NOT all players have picked for this round.');
      
      intDraftPicksCurrentPlayerIndex = intDraftPicksCurrentPlayerIndex + 1;
      console.log('intDraftPicksCurrentPlayerIndex = ' + intDraftPicksCurrentPlayerIndex);
      console.log('arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex] = ' + arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex]);

      draftCurrentPickTarget.value = 'p' + arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex] + '-pick' + getPlayerPickNumber(arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex]  );
      draftCurrentPickTarget.dispatchEvent(new Event('change'));

    }
    
    console.log('arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex]: ' + arrDraftPicksPlayerOrder[intDraftPicksCurrentPlayerIndex]);


  } else {

    // prepare for deck/ban pick selection
    var tempPickTargetInputValue = this.value;
    console.log('pick: ' + tempPickTargetInputValue);
    
    var draftCurrentPickTargetPlayer = tempPickTargetInputValue.slice(1, 2);
    var draftCurrentPickType = arrDraftPicksOrdering[arrDraftPicksOrderingCurrent];
    //var draftCurrentPickNumber = parseInt(draftCurrentPickTargetPlayer);
    //alert(draftCurrentPickTargetPlayer);
    //draftCurrentPickNumber = getPlayerPickNumber(draftCurrentPickNumber);
    

    console.log("draftCurrentPickType:" + draftCurrentPickType)
    
    if (draftCurrentPickType == "deck"){

      console.log('draftCurrentPlayerDeckPick ID: js-playerCard-' + tempPickTargetInputValue);

      draftCurrentPlayerDeckPick = document.getElementById('js-playerCard-' + tempPickTargetInputValue);
    
      // show styling on deck grid
      deckGrid.classList.add("deckGrid--p" + draftCurrentPickTargetPlayer + "Pick");
  
      console.log("draftCurrentPlayerDeckPick: " + draftCurrentPlayerDeckPick);
  
      // show styling on player card pick
      draftCurrentPlayerDeckPick.classList.add("playerCard__deckPick--pickTarget");
      
      // add class to highlight current player's playerCard block
      var pickTargetplayerCardElement = document.querySelector(".playerCard__deckPick--pickTarget");
      pickTargetplayerCardElement = draftCurrentPlayerDeckPick.parentElement;
      pickTargetplayerCardElement.classList.add('playerCard--pickTarget');
  
    } else if (draftCurrentPickType == "ban"){

      alert('we did it.');

    }

  }
  
});

// confirm the selected pick -- assign the pick to the appropriate player
function confirmSelectedPick(){

  // assign selected deck to current pick target

  
  console.log('confirm ' + draftCurrentDeckSelection.value + ' for ' + draftCurrentPickTarget.value);
  console.log('js-playerCard-' + draftCurrentPickTarget.value);

  if (draftCurrentPickTarget.value != "none"){

    // set deck image and update hidden element for player deck pick
    draftCurrentPlayerDeckPick = document.getElementById('js-playerCard-' + draftCurrentPickTarget.value);
    draftCurrentPlayerDeckPick.style.backgroundImage = 'url("img/'+ draftCurrentDeckSelection.value + '.png';

    let draftCurrentPlayerDeckPickInput = document.getElementById('js-' + draftCurrentPickTarget.value + '-input');
    draftCurrentPlayerDeckPickInput.value = draftCurrentDeckSelection.value;

    // update deckData with picked deck
    let codeToFind = draftCurrentDeckSelection.value;
    for (let i = 0; i < draftDeckData.length; i++) {
      let deck = draftDeckData[i];
      if (deck.code === codeToFind) {
        deck.isPicked = true;
        deck.pickedBy = draftCurrentPickTarget.value;
        console.log(deck);
        break;
      }
    }
    // add styling to denote picked deck
    let pickedDeck = document.getElementById('js-deckButton-' + draftCurrentDeckSelection.value);
    console.log('pickedDeck ID: ' + 'js-deckButton-' + draftCurrentDeckSelection.value)
    pickedDeck.classList.add("deckGrid__deckButton--isPicked");
    pickedDeck.classList.add("deckGrid__deckButton--pickedBy-p" + draftCurrentPickTarget.value.slice(1, 2));
    pickedDeck.dataset.isPicked = true; // data-code attribute

    // play sound effect
    soundElementClick = document.getElementById('js-sound-click');
    soundElementClick.volume = 0.5;
    soundElementClick.currentTime = 0; // reset the current time to the start
    soundElementClick.play();

    
    // ok done assigning the selected pick, clear the current pick target hidden element
    draftCurrentPickTarget.value = "none";
    draftCurrentPickTarget.dispatchEvent(new Event('change'));
  }

  // if this is a random pick draft, then generate a new deck picker element
  if (draftPickType == "randomized") {
    generateDeckPicker("randomized", draftSet);
  }

  hideDeckLightbox();
  
}

/*
let timer = 5;
let countdown = setInterval(function() {
    timer--;
    console.log(timer + " seconds remaining");
    if (timer === 0) {
        clearInterval(countdown);
        draftCurrentPickTarget.value = 'p1-p2'; // set current pick target hidden element
        draftCurrentPickTarget.dispatchEvent(new Event('change'));
    }
}, 1000);
*/

// ============================================================================
// preload deck images
let deckImages = [];
// loop through the decks in the JSON data
gameData.decks.forEach((deck, index) => {

        //PRELOAD IMAGES: create a new image object and set the source to the deck's image
        let img = new Image();
        img.src = deck.image;
        // add the image object to the deckImages array
        deckImages.push(img);
});


// ============================================================================
// deck lightbox open/close functions
const deckLightbox = document.getElementById("js-deckLightbox");

let confirmSelectedPickHandler = () => {
  confirmSelectedPick();
};

function showDeckLightbox(boolIsDraftPick) {

  // decide whether to show confirm pick button
  if (boolIsDraftPick) {
    draftConfirmPickButton.addEventListener("click", confirmSelectedPickHandler);
    draftConfirmPickButton.style.visibility = "visible"
  } else {
    draftConfirmPickButton.style.visibility = "hidden "
  }

  deckLightbox.classList.add("deckLightbox--show");

}

function hideDeckLightbox() {
  deckLightbox.classList.remove("deckLightbox--show");

  draftConfirmPickButton.removeEventListener("click", confirmSelectedPickHandler);
  console.log('ok remove draftConfirmPickButton listener');
}

deckInfoLeft.addEventListener("click", function(event) {
    hideDeckLightbox();
});

// close lightbox when user hits esc
document.addEventListener("keydown", function(event) {
  if (event.key === "Escape") {
    hideDeckLightbox();
  }
});


// ============================================================================
// Dynamically generated lightbox overlay 

function generateLightbox(lightboxContent){

  // create lightbox elements
  const lightboxOverlay = document.createElement('div');
  lightboxOverlay.classList.add('lightbox-overlay');

  const lightbox = document.createElement('div');
  lightbox.classList.add('lightbox');
  lightbox.innerHTML = '<p style="padding-bottom:16px;">' + lightboxContent + '</p><button id="close-lightbox-button">OK</button>';

  lightboxOverlay.appendChild(lightbox);
  document.body.appendChild(lightboxOverlay);

  const closeLightboxButton = lightbox.querySelector('#close-lightbox-button');
  closeLightboxButton.addEventListener('click', () => {
    document.body.removeChild(lightboxOverlay);
  });

  lightboxOverlay.addEventListener('click', (event) => {
    if (event.target === lightboxOverlay) {
      document.body.removeChild(lightboxOverlay);
    }
  });

}


// ============================================================================
// function that will return the current pick number for the given player

function getPlayerPickNumber(playerNum) { 

  if (typeof playerNum === 'undefined') {
    alert('yo playerNum i undefined!')
  }

  console.log("getPlayerPickNumber(" + playerNum + ")")

  let currentPlayerPick1InputValue = document.getElementById('js-p' + playerNum + '-pick1-input');
      currentPlayerPick1InputValue = currentPlayerPick1InputValue.value;
      console.log("currentPlayerPick1InputValue: " + currentPlayerPick1InputValue);
  let currentPlayerPick2InputValue = document.getElementById('js-p' + playerNum + '-pick2-input');
      currentPlayerPick2InputValue = currentPlayerPick2InputValue.value;
      console.log("currentPlayerPick2InputValue: " + currentPlayerPick2InputValue);

  if (currentPlayerPick1InputValue == 'none'){
    return 1;
  } else if (currentPlayerPick2InputValue == 'none'){
    return 2;
  } else { // no deck picks left 
    alert ('Error: both picks from player ' + playerNum + ' are completed')
  }


}


// ============================================================================
// Function to generate the deck select
function generateDeckPicker(pickType, selectedSet) {
  
      if (pickType == "randomized") {
        // destroy the old deck picker element
        deckGrid.innerHTML = "";
      }

      // create temporary deck data object with the subset of decks for the given set 
      let tempDeckData = structuredClone(draftDeckData);
      for (let i = tempDeckData.length - 1; i >= 0; i--) {
        if (selectedSet == "basic") {
          if (tempDeckData[i].set != selectedSet) {
            //console.log('splice ' + tempDeckData[i].name);
            tempDeckData.splice(i, 1);
          }
        } else if (selectedSet == "intermediate") {
          if (tempDeckData[i].set == "advanced") {
            //console.log('splice ' + tempDeckData[i].name);
            tempDeckData.splice(i, 1);
          }
        }
      }

      function generateDeckButton(objDeckData, boolAddTodeckGrid){

        let deckButton = document.createElement('button');
        deckButton.type = 'button';
        deckButton.id = 'js-deckButton-' + objDeckData.code;
        deckButton.classList.add('deckGrid__deckButton');
        deckButton.dataset.code = objDeckData.code; // data-code attribute
        deckButton.style = 'background-image: url("img/'+ objDeckData.code + '.png");';
        deckButton.addEventListener("click", () => {

          // set hidden state input
          draftCurrentDeckSelection.value = objDeckData.code;

          deckInfoLeft.style.background = 'url("img/'+ objDeckData.code + '.png")';
          deckInfoLeft.style.backgroundSize = '100%';
          deckInfoRight.innerHTML = `<h2 class="deckLightbox__heading">${objDeckData.name}</h2>
                                <p class="deckLightbox__description">${objDeckData.description}</p>`

          // check status of deck pick vs current deck data
          let codeToFind = objDeckData.code;
          let boolisPicked = false;
          
          // TODO: remove this and only query deck data once (see tempDeckData above)
          // loop through current deck data
          for (let i = 0; i < draftDeckData.length; i++) {
            let deck = draftDeckData[i];
            if (deck.code == codeToFind) {

              
              // found matching deck, is it picked?
              if (deck.isPicked == true) {
                console.log('this deck is already picked');
                boolisPicked = true;
              }

              // show decklist
              function hasDecklist(obj) { // does this deck have a decklist object?
                return "decklist" in obj;
              }

              if (hasDecklist(deck)){
                console.log('this deck has a decklist');
                var currentDeckDecklist = document.createElement('ul');
                currentDeckDecklist.classList.add('deckLightbox__decklist');

                for (let n = 0; n < deck.decklist.length; n++) {
                  console.log('found card: ' + deck.decklist[n])
                  var currentDeckCard = document.createElement('li');
                  currentDeckCard.innerHTML = deck.decklist[n].cardName;
                  if (deck.decklist[n].copies > 0){
                    currentDeckCard.innerHTML = currentDeckCard.innerHTML + " x " + deck.decklist[n].copies
                  }
                  currentDeckDecklist.appendChild(currentDeckCard);

                }   

                deckInfoRight.appendChild(currentDeckDecklist);

              }   
              break;
            }
          }

          // check if this deck is picked to decide how to call function
          if (!boolisPicked) {
            showDeckLightbox(true); // showDeckLightbox(boolIsDraftPick)
          } else {
            showDeckLightbox(false);
          }
        
          


          
        });
        
        // add sound effect on click - how is this even working?
        deckButton.addEventListener('click', function() {
          soundElementWoosh = document.getElementById('js-sound-woosh');
          soundElementWoosh.volume = 0.1;
          soundElementWoosh.currentTime = 0; // reset the current time to the start
          soundElementWoosh.play();
        });

        if (boolAddTodeckGrid) {
          deckGrid.appendChild(deckButton);
        } else {
          return deckButton; // TODO: delete if not going to use this
        } 
      }

      // add styling modifier to deckGrid block
      deckGrid.classList.add('deckGrid__' + pickType + 'Pick');
      //console.log(gameData.decks);
      //console.log(tempDeckData);
      if (pickType == "standard"){

        // display all decks
        tempDeckData.forEach((deck, index) => {
          generateDeckButton(deck,"true");
        });

      } else if (pickType == "randomized"){

        // display 3 random decks
        const arrRandomDeckIDs = [];
        for (let i = 0; i < 3; i++) {
          let randomDeckNumber = Math.floor(Math.random() * tempDeckData.length);
          while (arrRandomDeckIDs.includes(randomDeckNumber)) {
            randomDeckNumber = Math.floor(Math.random() * tempDeckData.length);
          }
          arrRandomDeckIDs.push(randomDeckNumber);
          generateDeckButton(tempDeckData[randomDeckNumber],"true");
        }
        
      } else {
        alert('unrecognized pick type')
      }

}

// ============================================================================
// Function to initiate first draft deck/ban pick by setting current pick target hidden input
function draftInitializeFirstPick(firstPickPlayer, firstPickType){

    if (firstPickType == "deck") {

      // figure out what pick # this is for current player
      let firstPickNum = getPlayerPickNumber(firstPickPlayer);

      draftCurrentPickTarget.value = 'p' + firstPickPlayer + '-pick' + firstPickNum;
      draftCurrentPickTarget.dispatchEvent(new Event('change'));

    } else if (firstPickType == "ban") { 
      alert('uh oh it wants a ban! help I need an adult!')
    } else{
      alert('yikes this pick is not a deck or a ban!')
    } 
}


// ============================================================================
// Determine starting player and set player pick order

function draftInitializePlayerPickOrder(){

  console.log('initialize pick order - type: ' + draftFirstPlayerType);

  // set initial order with p1 first
  let arrTempPlayerOrder = [];
  for (let i = 0; i <= (draftNumPlayers-1); i++) {
    arrTempPlayerOrder.push(i+1);
  }

  if (draftFirstPlayerType == "p1") {

    return arrTempPlayerOrder;
    
  } else if (draftFirstPlayerType == "random") {

    // randomize player order array
    function createTurnOrder(numPlayers) {

      let firstPlayer = arrTempPlayerOrder.splice(Math.floor(Math.random() * arrTempPlayerOrder.length), 1)[0];
      let turnOrder = [firstPlayer];

      while (arrTempPlayerOrder.length > 0) {
        let nextPlayer = arrTempPlayerOrder.splice(arrTempPlayerOrder .indexOf(firstPlayer % numPlayers + 1), 1)[0];
        turnOrder.push(nextPlayer);
        firstPlayer = nextPlayer;
      }

      return turnOrder;
    }

    return createTurnOrder(draftNumPlayers);

  } else {
    alert('uh oh unrecognized first player pick type');
  }

}


// ============================================================================
// Start Draft

var arrDraftPicksOrdering = ["deck", "deck", "ban"]; // TODO: dynamically create this array
var arrDraftPicksOrderingCurrent = 0;

// get correct player pick order based on pick type selected
var arrDraftPicksPlayerOrder = draftInitializePlayerPickOrder();
console.log("arrDraftPicksPlayerOrder: " + arrDraftPicksPlayerOrder);
console.log("arrDraftPicksPlayerOrder[0]: " + arrDraftPicksPlayerOrder[0]);
console.log("arrDraftPicksPlayerOrder[1]: " + arrDraftPicksPlayerOrder[1]);
console.log("arrDraftPicksPlayerOrder[2]: " + arrDraftPicksPlayerOrder[2]);
console.log("arrDraftPicksPlayerOrder[3]: " + arrDraftPicksPlayerOrder[3]);


var arrDraftPicksCurrentPlayer = arrDraftPicksPlayerOrder[0];
var intDraftPicksCurrentPlayerIndex = 0;

generateLightbox("player " + arrDraftPicksPlayerOrder[0] + " goes first!<br><br>Lets draft " + draftSet + " decks with " + draftNumPlayers + " players using " + draftPickType + " pick (bans: " + draftBans + ")");

console.log("generateDeckPicker(" + draftPickType + "," + draftSet + ")");
generateDeckPicker(draftPickType, draftSet);

console.log("draftInitializeFirstPick: " + arrDraftPicksPlayerOrder[0], arrDraftPicksOrdering[0]);
draftInitializeFirstPick(arrDraftPicksPlayerOrder[0], arrDraftPicksOrdering[0]);

